import {
    ResetPasswordTokenData,
    changePasswordInterface,
    httpStatusCode,
} from '@customtype/index';
import db from '@db/index';
import { NewToken, TokenData, User, tokens, users } from '@db/schema';
import { CustomError } from '@utils/CustomError';
import { eq } from 'drizzle-orm';
import bcrypt from 'bcrypt';
import jwt, { SignOptions } from 'jsonwebtoken';
import { getPrivateKeySecret, options } from '@utils/jwt';

type UserDetails = Omit<User, 'password'>;

interface userservice {
    isUserExist(id: string): Promise<UserDetails | undefined>;
    changePassword(
        newpassword: string,
        oldpassword: string,
        confirmpassword: string,
        user_id: string,
    ): Promise<changePasswordInterface>;
    isTokenExist(userId: string): Promise<any | undefined>;
    isUserByEmail(email: string): Promise<UserDetails | undefined>;
    generateResetPasswordToken(data: ResetPasswordTokenData): string;
    addResetPasswordToken(token: string, user_id: string): Promise<NewToken>;
}

class UserService implements userservice {
    jwtTokenOption: SignOptions;

    constructor() {
        this.jwtTokenOption = options;
    }

    async addResetPasswordToken(
        token: string,
        userId: string,
    ): Promise<NewToken> {
        const insertToken = await db
            .insert(tokens)
            .values({ token, userId })
            .returning();
    }

    generateResetPasswordToken(data: ResetPasswordTokenData): string {
        const token = jwt.sign(data, getPrivateKeySecret(), {
            ...this.jwtTokenOption,
            expiresIn: '10m',
        });
        return token;
    }

    async isUserByEmail(email: string): Promise<UserDetails | undefined> {
        const user = await db.query.users.findFirst({
            where: eq(users.email, email),
            columns: {
                password: false,
            },
        });
        return user;
    }
    async isTokenExist(userId: string): Promise<any | undefined> {
        const isToken = await db.query.tokens.findFirst({
            where: eq(tokens.userId, userId),
            with: {
                user: {
                    columns: {
                        password: false,
                        createdAt: false,
                        name: false,
                    },
                },
            },
        });
        return isToken;
    }
    async changePassword(
        newpassword: string,
        oldpassword: string,
        confirmpassword: string,
        user_id: string,
    ): Promise<changePasswordInterface> {
        if (newpassword !== confirmpassword) {
            throw new CustomError(
                "Your password does'n match.",
                httpStatusCode.BAD_REQUEST,
            );
        }
        const isUserExist = await db.query.users.findFirst({
            where: eq(users.id, user_id),
        });
        if (!isUserExist) {
            throw new CustomError(
                'User does not exist.',
                httpStatusCode.BAD_REQUEST,
            );
        }

        const isValidPassword = await bcrypt.compare(
            oldpassword,
            isUserExist.password,
        );
        if (!isValidPassword) {
            throw new CustomError(
                'Invalid password',
                httpStatusCode.BAD_REQUEST,
            );
        }

        const hashPassword = await bcrypt.hash(newpassword, 10);

        const updatePassword = await db
            .update(users)
            .set({ password: hashPassword })
            .where(eq(users.id, user_id));

        return updatePassword?.rowCount === 1
            ? { success: true }
            : { success: false };
    }

    async isUserExist(id: string): Promise<UserDetails | undefined> {
        const isUser = await db.query.users.findFirst({
            where: eq(users.id, id),
            columns: {
                password: false,
            },
        });
        return isUser;
    }
}

export default UserService;
